# A questão

![41 Questão](../../assets/41_first_missing_positive/41_question.png)

# Estratégia

A ideia desse problema é simples de enunciar: precisamos achar o menor número positivo que não está no array.  
O detalhe é que o algoritmo tem que rodar em O(n) e não pode usar espaço extra além do próprio array.

O truque está em perceber que, se o array tem tamanho `n`, a resposta só pode estar no intervalo de `1` até `n+1`.  
Ou seja, não importa se aparecerem números negativos ou muito grandes, eles não influenciam na resposta.

O que eu fiz foi tentar colocar cada número no “seu lugar certo”:  
- o número `1` deveria estar na posição `0`,  
- o número `2` na posição `1`,  
- e assim por diante.  

Enquanto percorro o array, se vejo um valor que deveria estar em outro índice, faço a troca.  
No final, passo de novo e procuro o primeiro índice `i` em que `nums[i] != i+1`. Esse `i+1` é a resposta.  
Se não encontrar, quer dizer que o array tinha todos os números de `1` a `n`, então a resposta é `n+1`.

# Algoritmo utilizado

É uma espécie de **ciclo de reposicionamento** dentro do próprio array.  
Cada número é trocado até estar no índice correto, e como cada valor só pode ser trocado algumas vezes, a complexidade continua O(n).

# Resultado

A solução passou nos testes, conforme atesta a imagem a seguir.

![41 Accepted](../../assets/41_first_missing_positive/41_accepted.png)
